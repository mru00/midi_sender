   1               	# 1 "usbdrv/usbdrvasm.S"
   1               	/* Name: usbdrvasm.S
   0               	
   0               	
   2               	 * Project: AVR USB driver
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2007-06-13
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
   8               	 * Revision: $Id$
   9               	 */
  10               	
  11               	/*
  12               	General Description:
  13               	This module is the assembler part of the USB driver. This file contains
  14               	general code (preprocessor acrobatics and CRC computation) and then includes
  15               	the file appropriate for the given clock rate.
  16               	*/
  17               	
  18               	#include "iarcompat.h"
   1               	/* Name: iarcompat.h
  19               	#ifndef __IAR_SYSTEMS_ASM__
  20               	    /* configs for io.h */
  21               	#   define __SFR_OFFSET 0
  22               	#   define _VECTOR(N)   __vector_ ## N   /* io.h does not define this for asm */
  23               	#   include <avr/io.h> /* for CPU I/O register definitions and vectors */
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h,v 1.24.2.25 2007/10/25 12:24:31 aesok Exp $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    A constant describing the last on-chip RAM location.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    A constant describing the last possible location in RAM.
  75               	    This is equal to RAMEND for devices that do not allow for
  76               	    external RAM.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    A constant describing the address of the last EEPROM cell.
  81               	    <br>
  82               	    - \b FLASHEND
  83               	    <br>
  84               	    A constant describing the last byte address in flash ROM.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. */
  90               	
  91               	#ifndef _AVR_IO_H_
  92               	#define _AVR_IO_H_
  93               	
  94               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
  95               	
  96               	#if defined (__AVR_AT94K__)
  97               	#  include <avr/ioat94k.h>
  98               	#elif defined (__AVR_AT43USB320__)
  99               	#  include <avr/io43u32x.h>
 100               	#elif defined (__AVR_AT43USB355__)
 101               	#  include <avr/io43u35x.h>
 102               	#elif defined (__AVR_AT76C711__)
 103               	#  include <avr/io76c711.h>
 104               	#elif defined (__AVR_AT86RF401__)
 105               	#  include <avr/io86r401.h>
 106               	#elif defined (__AVR_AT90PWM1__)
 107               	#  include <avr/io90pwm1.h>
 108               	#elif defined (__AVR_AT90PWM2__)
 109               	#  include <avr/io90pwmx.h>
 110               	#elif defined (__AVR_AT90PWM2B__)
 111               	#  include <avr/io90pwm2b.h>
 112               	#elif defined (__AVR_AT90PWM3__)
 113               	#  include <avr/io90pwmx.h>
 114               	#elif defined (__AVR_AT90PWM3B__)
 115               	#  include <avr/io90pwm3b.h>
 116               	#elif defined (__AVR_AT90PWM216__)
 117               	#  include <avr/io90pwm216.h>
 118               	#elif defined (__AVR_AT90PWM316__)
 119               	#  include <avr/io90pwm316.h>
 120               	#elif defined (__AVR_ATmega128__)
 121               	#  include <avr/iom128.h>
 122               	#elif defined (__AVR_ATmega1280__)
 123               	#  include <avr/iom1280.h>
 124               	#elif defined (__AVR_ATmega1281__)
 125               	#  include <avr/iom1281.h>
 126               	#elif defined (__AVR_ATmega2560__)
 127               	#  include <avr/iom2560.h>
 128               	#elif defined (__AVR_ATmega2561__)
 129               	#  include <avr/iom2561.h>
 130               	#elif defined (__AVR_AT90CAN32__)
 131               	#  include <avr/iocan32.h>
 132               	#elif defined (__AVR_AT90CAN64__)
 133               	#  include <avr/iocan64.h>
 134               	#elif defined (__AVR_AT90CAN128__)
 135               	#  include <avr/iocan128.h>
 136               	#elif defined (__AVR_AT90USB82__)
 137               	#  include <avr/iousb82.h>
 138               	#elif defined (__AVR_AT90USB162__)
 139               	#  include <avr/iousb162.h>
 140               	#elif defined (__AVR_AT90USB646__)
 141               	#  include <avr/iousb646.h>
 142               	#elif defined (__AVR_AT90USB647__)
 143               	#  include <avr/iousb647.h>
 144               	#elif defined (__AVR_AT90USB1286__)
 145               	#  include <avr/iousb1286.h>
 146               	#elif defined (__AVR_AT90USB1287__)
 147               	#  include <avr/iousb1287.h>
 148               	#elif defined (__AVR_ATmega64__)
 149               	#  include <avr/iom64.h>
 150               	#elif defined (__AVR_ATmega640__)
 151               	#  include <avr/iom640.h>
 152               	#elif defined (__AVR_ATmega644__)
 153               	#  include <avr/iom644.h>
 154               	#elif defined (__AVR_ATmega644P__)
 155               	#  include <avr/iom644.h>
 156               	#elif defined (__AVR_ATmega645__)
 157               	#  include <avr/iom645.h>
 158               	#elif defined (__AVR_ATmega6450__)
 159               	#  include <avr/iom6450.h>
 160               	#elif defined (__AVR_ATmega649__)
 161               	#  include <avr/iom649.h>
 162               	#elif defined (__AVR_ATmega6490__)
 163               	#  include <avr/iom6490.h>
 164               	#elif defined (__AVR_ATmega103__)
 165               	#  include <avr/iom103.h>
 166               	#elif defined (__AVR_ATmega32__)
 167               	#  include <avr/iom32.h>
 168               	#elif defined (__AVR_ATmega323__)
 169               	#  include <avr/iom323.h>
 170               	#elif defined (__AVR_ATmega324P__)
 171               	#  include <avr/iom324.h>
 172               	#elif defined (__AVR_ATmega325__)
 173               	#  include <avr/iom325.h>
 174               	#elif defined (__AVR_ATmega325P__)
 175               	#  include <avr/iom325.h>
 176               	#elif defined (__AVR_ATmega3250__)
 177               	#  include <avr/iom3250.h>
 178               	#elif defined (__AVR_ATmega3250P__)
 179               	#  include <avr/iom3250.h>
 180               	#elif defined (__AVR_ATmega328P__)
 181               	#  include <avr/iom328p.h>
 182               	#elif defined (__AVR_ATmega329__)
 183               	#  include <avr/iom329.h>
 184               	#elif defined (__AVR_ATmega329P__)
 185               	#  include <avr/iom329.h>
 186               	#elif defined (__AVR_ATmega3290__)
 187               	#  include <avr/iom3290.h>
 188               	#elif defined (__AVR_ATmega3290P__)
 189               	#  include <avr/iom3290.h>
 190               	#elif defined (__AVR_ATmega406__)
 191               	#  include <avr/iom406.h>
 192               	#elif defined (__AVR_ATmega16__)
 193               	#  include <avr/iom16.h>
 194               	#elif defined (__AVR_ATmega161__)
 195               	#  include <avr/iom161.h>
 196               	#elif defined (__AVR_ATmega162__)
 197               	#  include <avr/iom162.h>
 198               	#elif defined (__AVR_ATmega163__)
 199               	#  include <avr/iom163.h>
 200               	#elif defined (__AVR_ATmega164P__)
 201               	#  include <avr/iom164.h>
 202               	#elif defined (__AVR_ATmega165__)
 203               	#  include <avr/iom165.h>
 204               	#elif defined (__AVR_ATmega165P__)
 205               	#  include <avr/iom165p.h>
 206               	#elif defined (__AVR_ATmega168__)
 207               	#  include <avr/iom168.h>
 208               	#elif defined (__AVR_ATmega168P__)
 209               	#  include <avr/iom168p.h>
 210               	#elif defined (__AVR_ATmega169__)
 211               	#  include <avr/iom169.h>
 212               	#elif defined (__AVR_ATmega169P__)
 213               	#  include <avr/iom169p.h>
 214               	#elif defined (__AVR_ATmega8HVA__)
 215               	#  include <avr/iom8hva.h>
 216               	#elif defined (__AVR_ATmega16HVA__)
 217               	#  include <avr/iom16hva.h>
 218               	#elif defined (__AVR_ATmega8__)
 219               	#  include <avr/iom8.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz
 220               	#elif defined (__AVR_ATmega48__)
 221               	#  include <avr/iom48.h>
 222               	#elif defined (__AVR_ATmega48P__)
 223               	#  include <avr/iom48p.h>
 224               	#elif defined (__AVR_ATmega88__)
 225               	#  include <avr/iom88.h>
 226               	#elif defined (__AVR_ATmega88P__)
 227               	#  include <avr/iom88p.h>
 228               	#elif defined (__AVR_ATmega8515__)
 229               	#  include <avr/iom8515.h>
 230               	#elif defined (__AVR_ATmega8535__)
 231               	#  include <avr/iom8535.h>
 232               	#elif defined (__AVR_AT90S8535__)
 233               	#  include <avr/io8535.h>
 234               	#elif defined (__AVR_AT90C8534__)
 235               	#  include <avr/io8534.h>
 236               	#elif defined (__AVR_AT90S8515__)
 237               	#  include <avr/io8515.h>
 238               	#elif defined (__AVR_AT90S4434__)
 239               	#  include <avr/io4434.h>
 240               	#elif defined (__AVR_AT90S4433__)
 241               	#  include <avr/io4433.h>
 242               	#elif defined (__AVR_AT90S4414__)
 243               	#  include <avr/io4414.h>
 244               	#elif defined (__AVR_ATtiny22__)
 245               	#  include <avr/iotn22.h>
 246               	#elif defined (__AVR_ATtiny26__)
 247               	#  include <avr/iotn26.h>
 248               	#elif defined (__AVR_AT90S2343__)
 249               	#  include <avr/io2343.h>
 250               	#elif defined (__AVR_AT90S2333__)
 251               	#  include <avr/io2333.h>
 252               	#elif defined (__AVR_AT90S2323__)
 253               	#  include <avr/io2323.h>
 254               	#elif defined (__AVR_AT90S2313__)
 255               	#  include <avr/io2313.h>
 256               	#elif defined (__AVR_ATtiny2313__)
 257               	#  include <avr/iotn2313.h>
 258               	#elif defined (__AVR_ATtiny13__)
 259               	#  include <avr/iotn13.h>
 260               	#elif defined (__AVR_ATtiny25__)
 261               	#  include <avr/iotn25.h>
 262               	#elif defined (__AVR_ATtiny45__)
 263               	#  include <avr/iotn45.h>
 264               	#elif defined (__AVR_ATtiny85__)
 265               	#  include <avr/iotn85.h>
 266               	#elif defined (__AVR_ATtiny24__)
 267               	#  include <avr/iotn24.h>
 268               	#elif defined (__AVR_ATtiny44__)
 269               	#  include <avr/iotn44.h>
 270               	#elif defined (__AVR_ATtiny84__)
 271               	#  include <avr/iotn84.h>
 272               	#elif defined (__AVR_ATtiny261__)
 273               	#  include <avr/iotn261.h>
 274               	#elif defined (__AVR_ATtiny461__)
 275               	#  include <avr/iotn461.h>
 276               	#elif defined (__AVR_ATtiny861__)
 277               	#  include <avr/iotn861.h>
 278               	#elif defined (__AVR_ATtiny43U__)
 279               	#  include <avr/iotn43u.h>
 280               	#elif defined (__AVR_ATtiny48__)
 281               	#  include <avr/iotn48.h>
 282               	/* avr1: the following only supported for assembler programs */
 283               	#elif defined (__AVR_ATtiny28__)
 284               	#  include <avr/iotn28.h>
 285               	#elif defined (__AVR_AT90S1200__)
 286               	#  include <avr/io1200.h>
 287               	#elif defined (__AVR_ATtiny15__)
 288               	#  include <avr/iotn15.h>
 289               	#elif defined (__AVR_ATtiny12__)
 290               	#  include <avr/iotn12.h>
 291               	#elif defined (__AVR_ATtiny11__)
 292               	#  include <avr/iotn11.h>
 293               	#else
 294               	#  if !defined(__COMPILING_AVR_LIBC__)
 295               	#    warning "device type not defined"
 296               	#  endif
 297               	#endif
 298               	
 299               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 300               	
 301               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 302               	
 303               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 304               	
 305               	/* Include fuse.h after individual IO header files. */
 306               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 307               	
 308               	/* Include lock.h after individual IO header files. */
 309               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 310               	
  24               	#endif  /* __IAR_SYSTEMS_ASM__ */
  25               	#include "usbdrv.h" /* for common defs */
   1               	/* Name: usbdrv.h
   2               	 * Project: AVR USB driver
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2004-12-29
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
   8               	 * This Revision: $Id: usbdrv.h 375 2007-07-07 12:01:52Z cs $
   9               	 */
  10               	
  11               	#ifndef __usbdrv_h_included__
  12               	#define __usbdrv_h_included__
  13               	#include "usbconfig.h"
   1               	/* Name: usbconfig.h
  14               	#include "iarcompat.h"
  26               	
  27               	
  28               	/* register names */
  29               	#define x1      r16
  30               	#define x2      r17
  31               	#define shift   r18
  32               	#define cnt     r19
  33               	#define x3      r20
  34               	#define x4      r21
  35               	#define bitcnt  r22
  36               	#define phase   x4
  37               	#define leap    x4
  38               	
  39               	/* Some assembler dependent definitions and declarations: */
  40               	
  41               	#ifdef __IAR_SYSTEMS_ASM__
  42               	
  43               	#   define nop2     rjmp    $+2 /* jump to next instruction */
  44               	#   define XL       r26
  45               	#   define XH       r27
  46               	#   define YL       r28
  47               	#   define YH       r29
  48               	#   define ZL       r30
  49               	#   define ZH       r31
  50               	#   define lo8(x)   LOW(x)
  51               	#   define hi8(x)   ((x)>>8)    /* not HIGH to allow XLINK to make a proper range check */
  52               	
  53               	    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
  54               	    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
  55               	    extern  usbTxBuf, usbMsgLen, usbTxLen1, usbTxBuf1, usbTxLen3, usbTxBuf3
  56               	    public  usbCrc16
  57               	    public  usbCrc16Append
  58               	
  59               	    COMMON  INTVEC
  60               	    ORG     INT0_vect
  61               	    rjmp    SIG_INTERRUPT0
  62               	    RSEG    CODE
  63               	
  64               	#else /* __IAR_SYSTEMS_ASM__ */
  65               	
  66               	#   define nop2     rjmp    .+0 /* jump to next instruction */
  67               	
  68               	    .text
  69               	    .global SIG_INTERRUPT0
  71               	    .global usbCrc16
  72               	    .global usbCrc16Append
  73               	
  74               	#endif /* __IAR_SYSTEMS_ASM__ */
  75               	
  76               	;----------------------------------------------------------------------------
  77               	; Utility functions
  78               	;----------------------------------------------------------------------------
  79               	
  80               	#ifdef __IAR_SYSTEMS_ASM__
  81               	/* Register assignments for usbCrc16 on IAR cc */
  82               	/* Calling conventions on IAR:
  83               	 * First parameter passed in r16/r17, second in r18/r19 and so on.
  84               	 * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
  85               	 * Result is passed in r16/r17
  86               	 * In case of the "tiny" memory model, pointers are only 8 bit with no
  87               	 * padding. We therefore pass argument 1 as "16 bit unsigned".
  88               	 */
  89               	RTMODEL "__rt_version", "3"
  90               	/* The line above will generate an error if cc calling conventions change.
  91               	 * The value "3" above is valid for IAR 4.10B/W32
  92               	 */
  93               	#   define argLen   r18 /* argument 2 */
  94               	#   define argPtrL  r16 /* argument 1 */
  95               	#   define argPtrH  r17 /* argument 1 */
  96               	
  97               	#   define resCrcL  r16 /* result */
  98               	#   define resCrcH  r17 /* result */
  99               	
 100               	#   define ptrL     ZL
 101               	#   define ptrH     ZH
 102               	#   define ptr      Z
 103               	#   define byte     r22
 104               	#   define bitCnt   r19
 105               	#   define polyL    r20
 106               	#   define polyH    r21
 107               	#   define scratch  r23
 108               	
 109               	#else  /* __IAR_SYSTEMS_ASM__ */ 
 110               	/* Register assignments for usbCrc16 on gcc */
 111               	/* Calling conventions on gcc:
 112               	 * First parameter passed in r24/r25, second in r22/23 and so on.
 113               	 * Callee must preserve r1-r17, r28/r29
 114               	 * Result is passed in r24/r25
 115               	 */
 116               	#   define argLen   r22 /* argument 2 */
 117               	#   define argPtrL  r24 /* argument 1 */
 118               	#   define argPtrH  r25 /* argument 1 */
 119               	
 120               	#   define resCrcL  r24 /* result */
 121               	#   define resCrcH  r25 /* result */
 122               	
 123               	#   define ptrL     XL
 124               	#   define ptrH     XH
 125               	#   define ptr      x
 126               	#   define byte     r18
 127               	#   define bitCnt   r19
 128               	#   define polyL    r20
 129               	#   define polyH    r21
 130               	#   define scratch  r23
 131               	
 132               	#endif
 133               	
 134               	; extern unsigned usbCrc16(unsigned char *data, unsigned char len);
 135               	; data: r24/25
 136               	; len: r22
 137               	; temp variables:
 138               	;   r18: data byte
 139               	;   r19: bit counter
 140               	;   r20/21: polynomial
 141               	;   r23: scratch
 142               	;   r24/25: crc-sum
 143               	;   r26/27=X: ptr
 144               	usbCrc16:
 145:usbdrv/usbdrvasm.S ****     mov     ptrL, argPtrL
 146:usbdrv/usbdrvasm.S ****     mov     ptrH, argPtrH
 147:usbdrv/usbdrvasm.S ****     ldi     resCrcL, 0xff
 148:usbdrv/usbdrvasm.S ****     ldi     resCrcH, 0xff
 149:usbdrv/usbdrvasm.S ****     ldi     polyL, lo8(0xa001)
 150:usbdrv/usbdrvasm.S ****     ldi     polyH, hi8(0xa001)
 151               	crcByteLoop:
 152:usbdrv/usbdrvasm.S ****     subi    argLen, 1
 153:usbdrv/usbdrvasm.S ****     brcs    crcReady
 154:usbdrv/usbdrvasm.S ****     ld      byte, ptr+
 155:usbdrv/usbdrvasm.S ****     ldi     bitCnt, 8
 156               	crcBitLoop:
 157:usbdrv/usbdrvasm.S ****     mov     scratch, byte
 158:usbdrv/usbdrvasm.S ****     eor     scratch, resCrcL
 159:usbdrv/usbdrvasm.S ****     lsr     resCrcH
 160:usbdrv/usbdrvasm.S ****     ror     resCrcL
 161:usbdrv/usbdrvasm.S ****     lsr     byte
 162:usbdrv/usbdrvasm.S ****     sbrs    scratch, 0
 163:usbdrv/usbdrvasm.S ****     rjmp    crcNoXor
 164:usbdrv/usbdrvasm.S ****     eor     resCrcL, polyL
 165:usbdrv/usbdrvasm.S ****     eor     resCrcH, polyH
 166               	crcNoXor:
 167:usbdrv/usbdrvasm.S ****     dec     bitCnt
 168:usbdrv/usbdrvasm.S ****     brne    crcBitLoop
 169:usbdrv/usbdrvasm.S ****     rjmp    crcByteLoop
 170               	crcReady:
 171:usbdrv/usbdrvasm.S ****     com     resCrcL
 172:usbdrv/usbdrvasm.S ****     com     resCrcH
 173:usbdrv/usbdrvasm.S ****     ret
 174               	
 175               	; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
 176               	usbCrc16Append:
 177:usbdrv/usbdrvasm.S ****     rcall   usbCrc16
 178:usbdrv/usbdrvasm.S ****     st      ptr+, resCrcL
 179:usbdrv/usbdrvasm.S ****     st      ptr+, resCrcH
 180:usbdrv/usbdrvasm.S ****     ret
 181               	
 182               	
 183               	;----------------------------------------------------------------------------
 184               	; Now include the clock rate specific code
 185               	;----------------------------------------------------------------------------
 186               	
 187               	#ifndef USB_CFG_CLOCK_KHZ
 188               	#   define USB_CFG_CLOCK_KHZ 12000
 189               	#endif
 190               	
 191               	#if USB_CFG_CLOCK_KHZ == 12000
 192               	#   include "usbdrvasm12.S"
   1               	/* Name: usbdrvasm12.S
   2               	 * Project: AVR USB driver
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2004-12-29
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
   8               	 * This Revision: $Id: usbdrvasm12.S 353 2007-06-21 19:05:08Z cs $
   9               	 */
  10               	
  11               	/* Do not link this file! Link usbdrvasm.S instead, which includes the
  12               	 * appropriate implementation!
  13               	 */
  14               	
  15               	/*
  16               	General Description:
  17               	This file is the 12 MHz version of the asssembler part of the USB driver. It
  18               	requires a 12 MHz crystal (not a ceramic resonator and not a calibrated RC
  19               	oscillator).
  20               	
  21               	See usbdrv.h for a description of the entire driver.
  22               	
  23               	Since almost all of this code is timing critical, don't change unless you
  24               	really know what you are doing! Many parts require not only a maximum number
  25               	of CPU cycles, but even an exact number of cycles!
  26               	
  27               	
  28               	Timing constraints according to spec (in bit times):
  29               	timing subject                                      min max    CPUcycles
  30               	---------------------------------------------------------------------------
  31               	EOP of OUT/SETUP to sync pattern of DATA0 (both rx) 2   16     16-128
  32               	EOP of IN to sync pattern of DATA0 (rx, then tx)    2   7.5    16-60
  33               	DATAx (rx) to ACK/NAK/STALL (tx)                    2   7.5    16-60
  34               	*/
  35               	
  36               	;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
  37               	;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
  38               	;max allowable interrupt latency: 34 cycles -> max 25 cycles interrupt disable
  39               	;max stack usage: [ret(2), YL, SREG, YH, shift, x1, x2, x3, cnt, x4] = 11 bytes
  40               	;Numbers in brackets are maximum cycles since SOF.
  41               	SIG_INTERRUPT0:
  42               	;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt
  43:usbdrv/usbdrvasm12.S ****     push    YL              ;2 [35] push only what is necessary to sync with edge ASAP
  44:usbdrv/usbdrvasm12.S ****     in      YL, SREG        ;1 [37]
  45:usbdrv/usbdrvasm12.S ****     push    YL              ;2 [39]
  46               	;----------------------------------------------------------------------------
  47               	; Synchronize with sync pattern:
  48               	;----------------------------------------------------------------------------
  49               	;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
  50               	;sync up with J to K edge during sync pattern -- use fastest possible loops
  51               	;first part has no timeout because it waits for IDLE or SE1 (== disconnected)
  52               	waitForJ:
  53:usbdrv/usbdrvasm12.S ****     sbis    USBIN, USBMINUS ;1 [40] wait for D- == 1
  54:usbdrv/usbdrvasm12.S ****     rjmp    waitForJ        ;2
  55               	waitForK:
  56               	;The following code results in a sampling window of 1/4 bit which meets the spec.
  57:usbdrv/usbdrvasm12.S ****     sbis    USBIN, USBMINUS
  58:usbdrv/usbdrvasm12.S ****     rjmp    foundK
  59:usbdrv/usbdrvasm12.S ****     sbis    USBIN, USBMINUS
  60:usbdrv/usbdrvasm12.S ****     rjmp    foundK
  61:usbdrv/usbdrvasm12.S ****     sbis    USBIN, USBMINUS
  62:usbdrv/usbdrvasm12.S ****     rjmp    foundK
  63:usbdrv/usbdrvasm12.S ****     sbis    USBIN, USBMINUS
  64:usbdrv/usbdrvasm12.S ****     rjmp    foundK
  65:usbdrv/usbdrvasm12.S ****     sbis    USBIN, USBMINUS
  66:usbdrv/usbdrvasm12.S ****     rjmp    foundK
  67:usbdrv/usbdrvasm12.S ****     rjmp    sofError
  68               	foundK:
  69               	;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
  70               	;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
  71               	;are cycles from center of first sync (double K) bit after the instruction
  72:usbdrv/usbdrvasm12.S ****     push    YH                  ;2 [2]
  73:usbdrv/usbdrvasm12.S ****     lds     YL, usbInputBufOffset;2 [4]
  74:usbdrv/usbdrvasm12.S ****     clr     YH                  ;1 [5]
  75:usbdrv/usbdrvasm12.S ****     subi    YL, lo8(-(usbRxBuf));1 [6]
  76:usbdrv/usbdrvasm12.S ****     sbci    YH, hi8(-(usbRxBuf));1 [7]
  77               	
  78:usbdrv/usbdrvasm12.S ****     sbis    USBIN, USBMINUS ;1 [8] we want two bits K [sample 1 cycle too early]
  79:usbdrv/usbdrvasm12.S ****     rjmp    haveTwoBitsK    ;2 [10]
  80:usbdrv/usbdrvasm12.S ****     pop     YH              ;2 [11] undo the push from before
  81:usbdrv/usbdrvasm12.S ****     rjmp    waitForK        ;2 [13] this was not the end of sync, retry
  82               	haveTwoBitsK:
  83               	;----------------------------------------------------------------------------
  84               	; push more registers and initialize values while we sample the first bits:
  85               	;----------------------------------------------------------------------------
  86:usbdrv/usbdrvasm12.S ****     push    shift           ;2 [16]
  87:usbdrv/usbdrvasm12.S ****     push    x1              ;2 [12]
  88:usbdrv/usbdrvasm12.S ****     push    x2              ;2 [14]
  89               	
  90:usbdrv/usbdrvasm12.S ****     in      x1, USBIN       ;1 [17] <-- sample bit 0
  91:usbdrv/usbdrvasm12.S ****     ldi     shift, 0xff     ;1 [18]
  92:usbdrv/usbdrvasm12.S ****     bst     x1, USBMINUS    ;1 [19]
  93:usbdrv/usbdrvasm12.S ****     bld     shift, 0        ;1 [20]
  94:usbdrv/usbdrvasm12.S ****     push    x3              ;2 [22]
  95:usbdrv/usbdrvasm12.S ****     push    cnt             ;2 [24]
  96               	    
  97:usbdrv/usbdrvasm12.S ****     in      x2, USBIN       ;1 [25] <-- sample bit 1
  98:usbdrv/usbdrvasm12.S ****     ser     x3              ;1 [26] [inserted init instruction]
  99:usbdrv/usbdrvasm12.S ****     eor     x1, x2          ;1 [27]
 100:usbdrv/usbdrvasm12.S ****     bst     x1, USBMINUS    ;1 [28]
 101:usbdrv/usbdrvasm12.S ****     bld     shift, 1        ;1 [29]
 102:usbdrv/usbdrvasm12.S ****     ldi     cnt, USB_BUFSIZE;1 [30] [inserted init instruction]
 103:usbdrv/usbdrvasm12.S ****     rjmp    rxbit2          ;2 [32]
 104               	
 105               	;----------------------------------------------------------------------------
 106               	; Receiver loop (numbers in brackets are cycles within byte after instr)
 107               	;----------------------------------------------------------------------------
 108               	
 109               	unstuff0:               ;1 (branch taken)
 110:usbdrv/usbdrvasm12.S ****     andi    x3, ~0x01   ;1 [15]
 111:usbdrv/usbdrvasm12.S ****     mov     x1, x2      ;1 [16] x2 contains last sampled (stuffed) bit
 112:usbdrv/usbdrvasm12.S ****     in      x2, USBIN   ;1 [17] <-- sample bit 1 again
 113:usbdrv/usbdrvasm12.S ****     ori     shift, 0x01 ;1 [18]
 114:usbdrv/usbdrvasm12.S ****     rjmp    didUnstuff0 ;2 [20]
 115               	
 116               	unstuff1:               ;1 (branch taken)
 117:usbdrv/usbdrvasm12.S ****     mov     x2, x1      ;1 [21] x1 contains last sampled (stuffed) bit
 118:usbdrv/usbdrvasm12.S ****     andi    x3, ~0x02   ;1 [22]
 119:usbdrv/usbdrvasm12.S ****     ori     shift, 0x02 ;1 [23]
 120:usbdrv/usbdrvasm12.S ****     nop                 ;1 [24]
 121:usbdrv/usbdrvasm12.S ****     in      x1, USBIN   ;1 [25] <-- sample bit 2 again
 122:usbdrv/usbdrvasm12.S ****     rjmp    didUnstuff1 ;2 [27]
 123               	
 124               	unstuff2:               ;1 (branch taken)
 125:usbdrv/usbdrvasm12.S ****     andi    x3, ~0x04   ;1 [29]
 126:usbdrv/usbdrvasm12.S ****     ori     shift, 0x04 ;1 [30]
 127:usbdrv/usbdrvasm12.S ****     mov     x1, x2      ;1 [31] x2 contains last sampled (stuffed) bit
 128:usbdrv/usbdrvasm12.S ****     nop                 ;1 [32]
 129:usbdrv/usbdrvasm12.S ****     in      x2, USBIN   ;1 [33] <-- sample bit 3
 130:usbdrv/usbdrvasm12.S ****     rjmp    didUnstuff2 ;2 [35]
 131               	
 132               	unstuff3:               ;1 (branch taken)
 133:usbdrv/usbdrvasm12.S ****     in      x2, USBIN   ;1 [34] <-- sample stuffed bit 3 [one cycle too late]
 134:usbdrv/usbdrvasm12.S ****     andi    x3, ~0x08   ;1 [35]
 135:usbdrv/usbdrvasm12.S ****     ori     shift, 0x08 ;1 [36]
 136:usbdrv/usbdrvasm12.S ****     rjmp    didUnstuff3 ;2 [38]
 137               	
 138               	unstuff4:               ;1 (branch taken)
 139:usbdrv/usbdrvasm12.S ****     andi    x3, ~0x10   ;1 [40]
 140:usbdrv/usbdrvasm12.S ****     in      x1, USBIN   ;1 [41] <-- sample stuffed bit 4
 141:usbdrv/usbdrvasm12.S ****     ori     shift, 0x10 ;1 [42]
 142:usbdrv/usbdrvasm12.S ****     rjmp    didUnstuff4 ;2 [44]
 143               	
 144               	unstuff5:               ;1 (branch taken)
 145:usbdrv/usbdrvasm12.S ****     andi    x3, ~0x20   ;1 [48]
 146:usbdrv/usbdrvasm12.S ****     in      x2, USBIN   ;1 [49] <-- sample stuffed bit 5
 147:usbdrv/usbdrvasm12.S ****     ori     shift, 0x20 ;1 [50]
 148:usbdrv/usbdrvasm12.S ****     rjmp    didUnstuff5 ;2 [52]
 149               	
 150               	unstuff6:               ;1 (branch taken)
 151:usbdrv/usbdrvasm12.S ****     andi    x3, ~0x40   ;1 [56]
 152:usbdrv/usbdrvasm12.S ****     in      x1, USBIN   ;1 [57] <-- sample stuffed bit 6
 153:usbdrv/usbdrvasm12.S ****     ori     shift, 0x40 ;1 [58]
 154:usbdrv/usbdrvasm12.S ****     rjmp    didUnstuff6 ;2 [60]
 155               	
 156               	; extra jobs done during bit interval:
 157               	; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs]
 158               	; bit 1:    se0 check
 159               	; bit 2:    overflow check
 160               	; bit 3:    recovery from delay [bit 0 tasks took too long]
 161               	; bit 4:    none
 162               	; bit 5:    none
 163               	; bit 6:    none
 164               	; bit 7:    jump, eor
 165               	rxLoop:
 166:usbdrv/usbdrvasm12.S ****     eor     x3, shift   ;1 [0] reconstruct: x3 is 0 at bit locations we changed, 1 at others
 167:usbdrv/usbdrvasm12.S ****     in      x1, USBIN   ;1 [1] <-- sample bit 0
 168:usbdrv/usbdrvasm12.S ****     st      y+, x3      ;2 [3] store data
 169:usbdrv/usbdrvasm12.S ****     ser     x3          ;1 [4]
 170:usbdrv/usbdrvasm12.S ****     nop                 ;1 [5]
 171:usbdrv/usbdrvasm12.S ****     eor     x2, x1      ;1 [6]
 172:usbdrv/usbdrvasm12.S ****     bst     x2, USBMINUS;1 [7]
 173:usbdrv/usbdrvasm12.S ****     bld     shift, 0    ;1 [8]
 174:usbdrv/usbdrvasm12.S ****     in      x2, USBIN   ;1 [9] <-- sample bit 1 (or possibly bit 0 stuffed)
 175:usbdrv/usbdrvasm12.S ****     andi    x2, USBMASK ;1 [10]
 176:usbdrv/usbdrvasm12.S ****     breq    se0         ;1 [11] SE0 check for bit 1
 177:usbdrv/usbdrvasm12.S ****     andi    shift, 0xf9 ;1 [12]
 178               	didUnstuff0:
 179:usbdrv/usbdrvasm12.S ****     breq    unstuff0    ;1 [13]
 180:usbdrv/usbdrvasm12.S ****     eor     x1, x2      ;1 [14]
 181:usbdrv/usbdrvasm12.S ****     bst     x1, USBMINUS;1 [15]
 182:usbdrv/usbdrvasm12.S ****     bld     shift, 1    ;1 [16]
 183               	rxbit2:
 184:usbdrv/usbdrvasm12.S ****     in      x1, USBIN   ;1 [17] <-- sample bit 2 (or possibly bit 1 stuffed)
 185:usbdrv/usbdrvasm12.S ****     andi    shift, 0xf3 ;1 [18]
 186:usbdrv/usbdrvasm12.S ****     breq    unstuff1    ;1 [19] do remaining work for bit 1
 187               	didUnstuff1:
 188:usbdrv/usbdrvasm12.S ****     subi    cnt, 1      ;1 [20]
 189:usbdrv/usbdrvasm12.S ****     brcs    overflow    ;1 [21] loop control
 190:usbdrv/usbdrvasm12.S ****     eor     x2, x1      ;1 [22]
 191:usbdrv/usbdrvasm12.S ****     bst     x2, USBMINUS;1 [23]
 192:usbdrv/usbdrvasm12.S ****     bld     shift, 2    ;1 [24]
 193:usbdrv/usbdrvasm12.S ****     in      x2, USBIN   ;1 [25] <-- sample bit 3 (or possibly bit 2 stuffed)
 194:usbdrv/usbdrvasm12.S ****     andi    shift, 0xe7 ;1 [26]
 195:usbdrv/usbdrvasm12.S ****     breq    unstuff2    ;1 [27]
 196               	didUnstuff2:
 197:usbdrv/usbdrvasm12.S ****     eor     x1, x2      ;1 [28]
 198:usbdrv/usbdrvasm12.S ****     bst     x1, USBMINUS;1 [29]
 199:usbdrv/usbdrvasm12.S ****     bld     shift, 3    ;1 [30]
 200               	didUnstuff3:
 201:usbdrv/usbdrvasm12.S ****     andi    shift, 0xcf ;1 [31]
 202:usbdrv/usbdrvasm12.S ****     breq    unstuff3    ;1 [32]
 203:usbdrv/usbdrvasm12.S ****     in      x1, USBIN   ;1 [33] <-- sample bit 4
 204:usbdrv/usbdrvasm12.S ****     eor     x2, x1      ;1 [34]
 205:usbdrv/usbdrvasm12.S ****     bst     x2, USBMINUS;1 [35]
 206:usbdrv/usbdrvasm12.S ****     bld     shift, 4    ;1 [36]
 207               	didUnstuff4:
 208:usbdrv/usbdrvasm12.S ****     andi    shift, 0x9f ;1 [37]
 209:usbdrv/usbdrvasm12.S ****     breq    unstuff4    ;1 [38]
 210:usbdrv/usbdrvasm12.S ****     nop2                ;2 [40]
 211:usbdrv/usbdrvasm12.S ****     in      x2, USBIN   ;1 [41] <-- sample bit 5
 212:usbdrv/usbdrvasm12.S ****     eor     x1, x2      ;1 [42]
 213:usbdrv/usbdrvasm12.S ****     bst     x1, USBMINUS;1 [43]
 214:usbdrv/usbdrvasm12.S ****     bld     shift, 5    ;1 [44]
 215               	didUnstuff5:
 216:usbdrv/usbdrvasm12.S ****     andi    shift, 0x3f ;1 [45]
 217:usbdrv/usbdrvasm12.S ****     breq    unstuff5    ;1 [46]
 218:usbdrv/usbdrvasm12.S ****     nop2                ;2 [48]
 219:usbdrv/usbdrvasm12.S ****     in      x1, USBIN   ;1 [49] <-- sample bit 6
 220:usbdrv/usbdrvasm12.S ****     eor     x2, x1      ;1 [50]
 221:usbdrv/usbdrvasm12.S ****     bst     x2, USBMINUS;1 [51]
 222:usbdrv/usbdrvasm12.S ****     bld     shift, 6    ;1 [52]
 223               	didUnstuff6:
 224:usbdrv/usbdrvasm12.S ****     cpi     shift, 0x02 ;1 [53]
 225:usbdrv/usbdrvasm12.S ****     brlo    unstuff6    ;1 [54]
 226:usbdrv/usbdrvasm12.S ****     nop2                ;2 [56]
 227:usbdrv/usbdrvasm12.S ****     in      x2, USBIN   ;1 [57] <-- sample bit 7
 228:usbdrv/usbdrvasm12.S ****     eor     x1, x2      ;1 [58]
 229:usbdrv/usbdrvasm12.S ****     bst     x1, USBMINUS;1 [59]
 230:usbdrv/usbdrvasm12.S ****     bld     shift, 7    ;1 [60]
 231               	didUnstuff7:
 232:usbdrv/usbdrvasm12.S ****     cpi     shift, 0x04 ;1 [61]
 233:usbdrv/usbdrvasm12.S ****     brsh    rxLoop      ;2 [63] loop control
 234               	unstuff7:
 235:usbdrv/usbdrvasm12.S ****     andi    x3, ~0x80   ;1 [63]
 236:usbdrv/usbdrvasm12.S ****     ori     shift, 0x80 ;1 [64]
 237:usbdrv/usbdrvasm12.S ****     in      x2, USBIN   ;1 [65] <-- sample stuffed bit 7
 238:usbdrv/usbdrvasm12.S ****     nop                 ;1 [66]
 239:usbdrv/usbdrvasm12.S ****     rjmp    didUnstuff7 ;2 [68]
 240               	
 241               	
 242               	;----------------------------------------------------------------------------
 243               	; Processing of received packet (numbers in brackets are cycles after end of SE0)
 244               	;----------------------------------------------------------------------------
 245               	;This is the only non-error exit point for the software receiver loop
 246               	;we don't check any CRCs here because there is no time left.
 247               	#define token   x1
 248               	se0:                            ;  [0]
 249:usbdrv/usbdrvasm12.S ****     subi    cnt, USB_BUFSIZE    ;1 [1]
 250:usbdrv/usbdrvasm12.S ****     neg     cnt                 ;1 [2]
 251:usbdrv/usbdrvasm12.S ****     cpi     cnt, 3              ;1 [3]
 252:usbdrv/usbdrvasm12.S ****     ldi     x2, 1<<USB_INTR_PENDING_BIT ;1 [4]
 253:usbdrv/usbdrvasm12.S ****     out     USB_INTR_PENDING, x2;1 [5] clear pending intr and check flag later. SE0 should be over.
 254:usbdrv/usbdrvasm12.S ****     brlo    doReturn            ;1 [6] this is probably an ACK, NAK or similar packet
 255:usbdrv/usbdrvasm12.S ****     sub     YL, cnt             ;1 [7]
 256:usbdrv/usbdrvasm12.S ****     sbci    YH, 0               ;1 [8]
 257:usbdrv/usbdrvasm12.S ****     ld      token, y            ;2 [10]
 258:usbdrv/usbdrvasm12.S ****     cpi     token, USBPID_DATA0 ;1 [11]
 259:usbdrv/usbdrvasm12.S ****     breq    handleData          ;1 [12]
 260:usbdrv/usbdrvasm12.S ****     cpi     token, USBPID_DATA1 ;1 [13]
 261:usbdrv/usbdrvasm12.S ****     breq    handleData          ;1 [14]
 262:usbdrv/usbdrvasm12.S ****     ldd     x2, y+1             ;2 [16] ADDR and 1 bit endpoint number
 263:usbdrv/usbdrvasm12.S ****     mov     x3, x2              ;1 [17] store for endpoint number
 264:usbdrv/usbdrvasm12.S ****     andi    x2, 0x7f            ;1 [18] x2 is now ADDR
 265:usbdrv/usbdrvasm12.S ****     lds     shift, usbDeviceAddr;2 [20]
 266:usbdrv/usbdrvasm12.S ****     cp      x2, shift           ;1 [21]
 267               	overflow:                       ; This is a hack: brcs overflow will never have Z flag set
 268:usbdrv/usbdrvasm12.S ****     brne    ignorePacket        ;1 [22] packet for different address
 269:usbdrv/usbdrvasm12.S ****     cpi     token, USBPID_IN    ;1 [23]
 270:usbdrv/usbdrvasm12.S ****     breq    handleIn            ;1 [24]
 271:usbdrv/usbdrvasm12.S ****     cpi     token, USBPID_SETUP ;1 [25]
 272:usbdrv/usbdrvasm12.S ****     breq    handleSetupOrOut    ;1 [26]
 273:usbdrv/usbdrvasm12.S ****     cpi     token, USBPID_OUT   ;1 [27]
 274:usbdrv/usbdrvasm12.S ****     breq    handleSetupOrOut    ;1 [28]
 275               	;   rjmp    ignorePacket        ;fallthrough, should not happen anyway.
 276               	
 277               	ignorePacket:
 278:usbdrv/usbdrvasm12.S ****     clr     shift
 279:usbdrv/usbdrvasm12.S ****     sts     usbCurrentTok, shift
 280               	doReturn:
 281:usbdrv/usbdrvasm12.S ****     pop     cnt
 282:usbdrv/usbdrvasm12.S ****     pop     x3
 283:usbdrv/usbdrvasm12.S ****     pop     x2
 284:usbdrv/usbdrvasm12.S ****     pop     x1
 285:usbdrv/usbdrvasm12.S ****     pop     shift
 286:usbdrv/usbdrvasm12.S ****     pop     YH
 287               	sofError:
 288:usbdrv/usbdrvasm12.S ****     pop     YL
 289:usbdrv/usbdrvasm12.S ****     out     SREG, YL
 290:usbdrv/usbdrvasm12.S ****     pop     YL
 291:usbdrv/usbdrvasm12.S ****     reti
 292               	
 293               	#if USB_CFG_HAVE_INTRIN_ENDPOINT && USB_CFG_HAVE_INTRIN_ENDPOINT3
 294               	handleIn3:                      ;1 [38] (branch taken)
 295               	    lds     cnt, usbTxLen3      ;2 [40]
 296               	    sbrc    cnt, 4              ;2 [42]
 297               	    rjmp    sendCntAndReti      ;0 43 + 17 = 60 until SOP
 298               	    sts     usbTxLen3, x1       ;2 [44] x1 == USBPID_NAK from above
 299               	    ldi     YL, lo8(usbTxBuf3)  ;1 [45]
 300               	    ldi     YH, hi8(usbTxBuf3)  ;1 [46]
 301               	    rjmp    usbSendAndReti      ;2 [48] + 13 = 61 until SOP (violates the spec by 1 cycle)
 302               	#endif
 303               	
 304               	;Setup and Out are followed by a data packet two bit times (16 cycles) after
 305               	;the end of SE0. The sync code allows up to 40 cycles delay from the start of
 306               	;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
 307               	handleSetupOrOut:               ;1 [29] (branch taken)
 308               	#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for second OUT endpoint, set usbCurrentTok t
 309               	    sbrc    x3, 7               ;1 [30] skip if endpoint 0
 310               	    ldi     token, -1           ;1 [31] indicate that this is endpoint 1 OUT
 311               	#endif
 312:usbdrv/usbdrvasm12.S ****     sts     usbCurrentTok, token;2 [33]
 313:usbdrv/usbdrvasm12.S ****     pop     cnt                 ;2 [35]
 314:usbdrv/usbdrvasm12.S ****     pop     x3                  ;2 [37]
 315:usbdrv/usbdrvasm12.S ****     pop     x2                  ;2 [39]
 316:usbdrv/usbdrvasm12.S ****     pop     x1                  ;2 [41]
 317:usbdrv/usbdrvasm12.S ****     pop     shift               ;2 [43]
 318:usbdrv/usbdrvasm12.S ****     pop     YH                  ;2 [45]
 319:usbdrv/usbdrvasm12.S ****     in      YL, USB_INTR_PENDING;1 [46]
 320:usbdrv/usbdrvasm12.S ****     sbrc    YL, USB_INTR_PENDING_BIT;1 [47] check whether data is already arriving
 321:usbdrv/usbdrvasm12.S ****     rjmp    waitForJ            ;2 [49] save the pops and pushes -- a new interrupt is aready pendi
 322:usbdrv/usbdrvasm12.S ****     rjmp    sofError            ;2 not an error, but it does the pops and reti we want
 323               	
 324               	
 325               	handleData:                     ;1 [15] (branch taken)
 326:usbdrv/usbdrvasm12.S ****     lds     token, usbCurrentTok;2 [17]
 327:usbdrv/usbdrvasm12.S ****     tst     token               ;1 [18]
 328:usbdrv/usbdrvasm12.S ****     breq    doReturn            ;1 [19]
 329:usbdrv/usbdrvasm12.S ****     lds     x2, usbRxLen        ;2 [21]
 330:usbdrv/usbdrvasm12.S ****     tst     x2                  ;1 [22]
 331:usbdrv/usbdrvasm12.S ****     brne    sendNakAndReti      ;1 [23]
 332               	; 2006-03-11: The following two lines fix a problem where the device was not
 333               	; recognized if usbPoll() was called less frequently than once every 4 ms.
 334:usbdrv/usbdrvasm12.S ****     cpi     cnt, 4              ;1 [24] zero sized data packets are status phase only -- ignore and
 335:usbdrv/usbdrvasm12.S ****     brmi    sendAckAndReti      ;1 [25] keep rx buffer clean -- we must not NAK next SETUP
 336:usbdrv/usbdrvasm12.S ****     sts     usbRxLen, cnt       ;2 [27] store received data, swap buffers
 337:usbdrv/usbdrvasm12.S ****     sts     usbRxToken, token   ;2 [29]
 338:usbdrv/usbdrvasm12.S ****     lds     x2, usbInputBufOffset;2 [31] swap buffers
 339:usbdrv/usbdrvasm12.S ****     ldi     cnt, USB_BUFSIZE    ;1 [32]
 340:usbdrv/usbdrvasm12.S ****     sub     cnt, x2             ;1 [33]
 341:usbdrv/usbdrvasm12.S ****     sts     usbInputBufOffset, cnt;2 [35] buffers now swapped
 342:usbdrv/usbdrvasm12.S ****     rjmp    sendAckAndReti      ;2 [37] + 19 = 56 until SOP
 343               	
 344               	handleIn:                       ;1 [25] (branch taken)
 345               	;We don't send any data as long as the C code has not processed the current
 346               	;input data and potentially updated the output data. That's more efficient
 347               	;in terms of code size than clearing the tx buffers when a packet is received.
 348:usbdrv/usbdrvasm12.S ****     lds     x1, usbRxLen        ;2 [27]
 349:usbdrv/usbdrvasm12.S ****     cpi     x1, 1               ;1 [28] negative values are flow control, 0 means "buffer free"
 350:usbdrv/usbdrvasm12.S ****     brge    sendNakAndReti      ;1 [29] unprocessed input packet?
 351:usbdrv/usbdrvasm12.S ****     ldi     x1, USBPID_NAK      ;1 [30] prepare value for usbTxLen
 352               	#if USB_CFG_HAVE_INTRIN_ENDPOINT
 353               	    sbrc    x3, 7               ;2 [33] x3 contains addr + endpoint
 354               	    rjmp    handleIn1           ;0
 355               	#endif
 356:usbdrv/usbdrvasm12.S ****     lds     cnt, usbTxLen       ;2 [34]
 357:usbdrv/usbdrvasm12.S ****     sbrc    cnt, 4              ;2 [36] all handshake tokens have bit 4 set
 358:usbdrv/usbdrvasm12.S ****     rjmp    sendCntAndReti      ;0 37 + 17 = 54 until SOP
 359:usbdrv/usbdrvasm12.S ****     sts     usbTxLen, x1        ;2 [38] x1 == USBPID_NAK from above
 360:usbdrv/usbdrvasm12.S ****     ldi     YL, lo8(usbTxBuf)   ;1 [39]
 361:usbdrv/usbdrvasm12.S ****     ldi     YH, hi8(usbTxBuf)   ;1 [40]
 362:usbdrv/usbdrvasm12.S ****     rjmp    usbSendAndReti      ;2 [42] + 14 = 56 until SOP
 363               	
 364               	; Comment about when to set usbTxLen to USBPID_NAK:
 365               	; We should set it back when we receive the ACK from the host. This would
 366               	; be simple to implement: One static variable which stores whether the last
 367               	; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
 368               	; ACK. However, we set it back immediately when we send the package,
 369               	; assuming that no error occurs and the host sends an ACK. We save one byte
 370               	; RAM this way and avoid potential problems with endless retries. The rest of
 371               	; the driver assumes error-free transfers anyway.
 372               	
 373               	#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* placed here due to relative jump range */
 374               	handleIn1:                      ;1 [33] (branch taken)
 375               	#if USB_CFG_HAVE_INTRIN_ENDPOINT3
 376               	; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
 377               	    ldd     x2, y+2             ;2 [35]
 378               	    sbrc    x2, 0               ;2 [37]
 379               	    rjmp    handleIn3           ;0
 380               	#endif
 381               	    lds     cnt, usbTxLen1      ;2 [39]
 382               	    sbrc    cnt, 4              ;2 [41] all handshake tokens have bit 4 set
 383               	    rjmp    sendCntAndReti      ;0 42 + 17 = 59 until SOP
 384               	    sts     usbTxLen1, x1       ;2 [43] x1 == USBPID_NAK from above
 385               	    ldi     YL, lo8(usbTxBuf1)  ;1 [44]
 386               	    ldi     YH, hi8(usbTxBuf1)  ;1 [45]
 387               	    rjmp    usbSendAndReti      ;2 [47] + 13 = 60 until SOP
 388               	#endif
 389               	
 390               	
 391               	;----------------------------------------------------------------------------
 392               	; Transmitting data
 393               	;----------------------------------------------------------------------------
 394               	
 395               	bitstuff0:                  ;1 (for branch taken)
 396:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1
 397:usbdrv/usbdrvasm12.S ****     ldi     x2, 0           ;1
 398:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 <-- out
 399:usbdrv/usbdrvasm12.S ****     rjmp    didStuff0       ;2 branch back 2 cycles earlier
 400               	bitstuff1:                  ;1 (for branch taken)
 401:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1
 402:usbdrv/usbdrvasm12.S ****     rjmp    didStuff1       ;2 we know that C is clear, jump back to do OUT and ror 0 into x2
 403               	bitstuff2:                  ;1 (for branch taken)
 404:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1
 405:usbdrv/usbdrvasm12.S ****     rjmp    didStuff2       ;2 jump back 4 cycles earlier and do out and ror 0 into x2
 406               	bitstuff3:                  ;1 (for branch taken)
 407:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1
 408:usbdrv/usbdrvasm12.S ****     rjmp    didStuff3       ;2 jump back earlier and ror 0 into x2
 409               	bitstuff4:                  ;1 (for branch taken)
 410:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1
 411:usbdrv/usbdrvasm12.S ****     ldi     x2, 0           ;1
 412:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 <-- out
 413:usbdrv/usbdrvasm12.S ****     rjmp    didStuff4       ;2 jump back 2 cycles earlier
 414               	
 415               	sendNakAndReti:                 ;0 [-19] 19 cycles until SOP
 416:usbdrv/usbdrvasm12.S ****     ldi     x3, USBPID_NAK      ;1 [-18]
 417:usbdrv/usbdrvasm12.S ****     rjmp    usbSendX3           ;2 [-16]
 418               	sendAckAndReti:                 ;0 [-19] 19 cycles until SOP
 419:usbdrv/usbdrvasm12.S ****     ldi     x3, USBPID_ACK      ;1 [-18]
 420:usbdrv/usbdrvasm12.S ****     rjmp    usbSendX3           ;2 [-16]
 421               	sendCntAndReti:                 ;0 [-17] 17 cycles until SOP
 422:usbdrv/usbdrvasm12.S ****     mov     x3, cnt             ;1 [-16]
 423               	usbSendX3:                      ;0 [-16]
 424:usbdrv/usbdrvasm12.S ****     ldi     YL, 20              ;1 [-15] 'x3' is R20
 425:usbdrv/usbdrvasm12.S ****     ldi     YH, 0               ;1 [-14]
 426:usbdrv/usbdrvasm12.S ****     ldi     cnt, 2              ;1 [-13]
 427               	;   rjmp    usbSendAndReti      fallthrough
 428               	
 429               	; USB spec says:
 430               	; idle = J
 431               	; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
 432               	; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
 433               	; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
 434               	
 435               	;usbSend:
 436               	;pointer to data in 'Y'
 437               	;number of bytes in 'cnt' -- including sync byte
 438               	;uses: x1...x4, shift, cnt, Y
 439               	;Numbers in brackets are time since first bit of sync pattern is sent
 440               	usbSendAndReti:             ;0 [-13] timing: 13 cycles until SOP
 441:usbdrv/usbdrvasm12.S ****     in      x2, USBDDR      ;1 [-12]
 442:usbdrv/usbdrvasm12.S ****     ori     x2, USBMASK     ;1 [-11]
 443:usbdrv/usbdrvasm12.S ****     sbi     USBOUT, USBMINUS;2 [-9] prepare idle state; D+ and D- must have been 0 (no pullups)
 444:usbdrv/usbdrvasm12.S ****     in      x1, USBOUT      ;1 [-8] port mirror for tx loop
 445:usbdrv/usbdrvasm12.S ****     out     USBDDR, x2      ;1 [-7] <- acquire bus
 446               	; need not init x2 (bitstuff history) because sync starts with 0
 447:usbdrv/usbdrvasm12.S ****     push    x4              ;2 [-5]
 448:usbdrv/usbdrvasm12.S ****     ldi     x4, USBMASK     ;1 [-4] exor mask
 449:usbdrv/usbdrvasm12.S ****     ldi     shift, 0x80     ;1 [-3] sync byte is first byte sent
 450               	txLoop:                     ;       [62]
 451:usbdrv/usbdrvasm12.S ****     sbrs    shift, 0        ;1 [-2] [62]
 452:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1 [-1] [63]
 453:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [0] <-- out bit 0
 454:usbdrv/usbdrvasm12.S ****     ror     shift           ;1 [1]
 455:usbdrv/usbdrvasm12.S ****     ror     x2              ;1 [2]
 456               	didStuff0:
 457:usbdrv/usbdrvasm12.S ****     cpi     x2, 0xfc        ;1 [3]
 458:usbdrv/usbdrvasm12.S ****     brsh    bitstuff0       ;1 [4]
 459:usbdrv/usbdrvasm12.S ****     sbrs    shift, 0        ;1 [5]
 460:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1 [6]
 461:usbdrv/usbdrvasm12.S ****     ror     shift           ;1 [7]
 462               	didStuff1:
 463:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [8] <-- out bit 1
 464:usbdrv/usbdrvasm12.S ****     ror     x2              ;1 [9]
 465:usbdrv/usbdrvasm12.S ****     cpi     x2, 0xfc        ;1 [10]
 466:usbdrv/usbdrvasm12.S ****     brsh    bitstuff1       ;1 [11]
 467:usbdrv/usbdrvasm12.S ****     sbrs    shift, 0        ;1 [12]
 468:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1 [13]
 469:usbdrv/usbdrvasm12.S ****     ror     shift           ;1 [14]
 470               	didStuff2:
 471:usbdrv/usbdrvasm12.S ****     ror     x2              ;1 [15]
 472:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [16] <-- out bit 2
 473:usbdrv/usbdrvasm12.S ****     cpi     x2, 0xfc        ;1 [17]
 474:usbdrv/usbdrvasm12.S ****     brsh    bitstuff2       ;1 [18]
 475:usbdrv/usbdrvasm12.S ****     sbrs    shift, 0        ;1 [19]
 476:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1 [20]
 477:usbdrv/usbdrvasm12.S ****     ror     shift           ;1 [21]
 478               	didStuff3:
 479:usbdrv/usbdrvasm12.S ****     ror     x2              ;1 [22]
 480:usbdrv/usbdrvasm12.S ****     cpi     x2, 0xfc        ;1 [23]
 481:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [24] <-- out bit 3
 482:usbdrv/usbdrvasm12.S ****     brsh    bitstuff3       ;1 [25]
 483:usbdrv/usbdrvasm12.S ****     nop2                    ;2 [27]
 484:usbdrv/usbdrvasm12.S ****     ld      x3, y+          ;2 [29]
 485:usbdrv/usbdrvasm12.S ****     sbrs    shift, 0        ;1 [30]
 486:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1 [31]
 487:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [32] <-- out bit 4
 488:usbdrv/usbdrvasm12.S ****     ror     shift           ;1 [33]
 489:usbdrv/usbdrvasm12.S ****     ror     x2              ;1 [34]
 490               	didStuff4:
 491:usbdrv/usbdrvasm12.S ****     cpi     x2, 0xfc        ;1 [35]
 492:usbdrv/usbdrvasm12.S ****     brsh    bitstuff4       ;1 [36]
 493:usbdrv/usbdrvasm12.S ****     sbrs    shift, 0        ;1 [37]
 494:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1 [38]
 495:usbdrv/usbdrvasm12.S ****     ror     shift           ;1 [39]
 496               	didStuff5:
 497:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [40] <-- out bit 5
 498:usbdrv/usbdrvasm12.S ****     ror     x2              ;1 [41]
 499:usbdrv/usbdrvasm12.S ****     cpi     x2, 0xfc        ;1 [42]
 500:usbdrv/usbdrvasm12.S ****     brsh    bitstuff5       ;1 [43]
 501:usbdrv/usbdrvasm12.S ****     sbrs    shift, 0        ;1 [44]
 502:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1 [45]
 503:usbdrv/usbdrvasm12.S ****     ror     shift           ;1 [46]
 504               	didStuff6:
 505:usbdrv/usbdrvasm12.S ****     ror     x2              ;1 [47]
 506:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [48] <-- out bit 6
 507:usbdrv/usbdrvasm12.S ****     cpi     x2, 0xfc        ;1 [49]
 508:usbdrv/usbdrvasm12.S ****     brsh    bitstuff6       ;1 [50]
 509:usbdrv/usbdrvasm12.S ****     sbrs    shift, 0        ;1 [51]
 510:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1 [52]
 511:usbdrv/usbdrvasm12.S ****     ror     shift           ;1 [53]
 512               	didStuff7:
 513:usbdrv/usbdrvasm12.S ****     ror     x2              ;1 [54]
 514:usbdrv/usbdrvasm12.S ****     cpi     x2, 0xfc        ;1 [55]
 515:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [56] <-- out bit 7
 516:usbdrv/usbdrvasm12.S ****     brsh    bitstuff7       ;1 [57]
 517:usbdrv/usbdrvasm12.S ****     mov     shift, x3       ;1 [58]
 518:usbdrv/usbdrvasm12.S ****     dec     cnt             ;1 [59]
 519:usbdrv/usbdrvasm12.S ****     brne    txLoop          ;1/2 [60/61]
 520               	;make SE0:
 521:usbdrv/usbdrvasm12.S ****     cbr     x1, USBMASK     ;1 [61] prepare SE0 [spec says EOP may be 15 to 18 cycles]
 522:usbdrv/usbdrvasm12.S ****     pop     x4              ;2 [63]
 523               	;brackets are cycles from start of SE0 now
 524:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [0] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
 525:usbdrv/usbdrvasm12.S ****     nop2                    ;2 [2]
 526               	;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
 527               	;set address only after data packet was sent, not after handshake
 528:usbdrv/usbdrvasm12.S ****     lds     x2, usbNewDeviceAddr;2 [4]
 529:usbdrv/usbdrvasm12.S ****     subi    YL, 20 + 2      ;1 [5]
 530:usbdrv/usbdrvasm12.S ****     sbci    YH, 0           ;1 [6]
 531:usbdrv/usbdrvasm12.S ****     breq    skipAddrAssign  ;2 [8]
 532:usbdrv/usbdrvasm12.S ****     sts     usbDeviceAddr, x2;0  if not skipped: SE0 is one cycle longer
 533               	skipAddrAssign:
 534               	;end of usbDeviceAddress transfer
 535:usbdrv/usbdrvasm12.S ****     ldi     x2, 1<<USB_INTR_PENDING_BIT;1 [9] int0 occurred during TX -- clear pending flag
 536:usbdrv/usbdrvasm12.S ****     out     USB_INTR_PENDING, x2;1 [10]
 537:usbdrv/usbdrvasm12.S ****     ori     x1, USBIDLE     ;1 [11]
 538:usbdrv/usbdrvasm12.S ****     in      x2, USBDDR      ;1 [12]
 539:usbdrv/usbdrvasm12.S ****     cbr     x2, USBMASK     ;1 [13] set both pins to input
 540:usbdrv/usbdrvasm12.S ****     mov     x3, x1          ;1 [14]
 541:usbdrv/usbdrvasm12.S ****     cbr     x3, USBMASK     ;1 [15] configure no pullup on both pins
 542:usbdrv/usbdrvasm12.S ****     out     USBOUT, x1      ;1 [16] <-- out J (idle) -- end of SE0 (EOP signal)
 543:usbdrv/usbdrvasm12.S ****     out     USBDDR, x2      ;1 [17] <-- release bus now
 544:usbdrv/usbdrvasm12.S ****     out     USBOUT, x3      ;1 [18] <-- ensure no pull-up resistors are active
 545:usbdrv/usbdrvasm12.S ****     rjmp    doReturn
 546               	
 547               	bitstuff5:                  ;1 (for branch taken)
 548:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1
 549:usbdrv/usbdrvasm12.S ****     rjmp    didStuff5       ;2 same trick as above...
 550               	bitstuff6:                  ;1 (for branch taken)
 551:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1
 552:usbdrv/usbdrvasm12.S ****     rjmp    didStuff6       ;2 same trick as above...
 553               	bitstuff7:                  ;1 (for branch taken)
 554:usbdrv/usbdrvasm12.S ****     eor     x1, x4          ;1
 555:usbdrv/usbdrvasm12.S ****     rjmp    didStuff7       ;2 same trick as above...
 556               	
DEFINED SYMBOLS
usbdrv/usbdrvasm12.S:41     .text:0000003a __vector_1
  usbdrv/usbdrvasm.S:144    .text:00000000 usbCrc16
  usbdrv/usbdrvasm.S:176    .text:00000032 usbCrc16Append
  usbdrv/usbdrvasm.S:151    .text:0000000c crcByteLoop
  usbdrv/usbdrvasm.S:170    .text:0000002c crcReady
  usbdrv/usbdrvasm.S:156    .text:00000014 crcBitLoop
  usbdrv/usbdrvasm.S:166    .text:00000026 crcNoXor
usbdrv/usbdrvasm12.S:52     .text:00000040 waitForJ
usbdrv/usbdrvasm12.S:55     .text:00000044 waitForK
usbdrv/usbdrvasm12.S:68     .text:0000005a foundK
usbdrv/usbdrvasm12.S:287    .text:00000196 sofError
usbdrv/usbdrvasm12.S:82     .text:0000006e haveTwoBitsK
usbdrv/usbdrvasm12.S:183    .text:000000f0 rxbit2
usbdrv/usbdrvasm12.S:109    .text:0000008e unstuff0
usbdrv/usbdrvasm12.S:178    .text:000000e8 didUnstuff0
usbdrv/usbdrvasm12.S:116    .text:00000098 unstuff1
usbdrv/usbdrvasm12.S:187    .text:000000f6 didUnstuff1
usbdrv/usbdrvasm12.S:124    .text:000000a4 unstuff2
usbdrv/usbdrvasm12.S:196    .text:00000106 didUnstuff2
usbdrv/usbdrvasm12.S:132    .text:000000b0 unstuff3
usbdrv/usbdrvasm12.S:200    .text:0000010c didUnstuff3
usbdrv/usbdrvasm12.S:138    .text:000000b8 unstuff4
usbdrv/usbdrvasm12.S:207    .text:00000118 didUnstuff4
usbdrv/usbdrvasm12.S:144    .text:000000c0 unstuff5
usbdrv/usbdrvasm12.S:215    .text:00000126 didUnstuff5
usbdrv/usbdrvasm12.S:150    .text:000000c8 unstuff6
usbdrv/usbdrvasm12.S:223    .text:00000134 didUnstuff6
usbdrv/usbdrvasm12.S:165    .text:000000d0 rxLoop
usbdrv/usbdrvasm12.S:248    .text:00000150 se0
usbdrv/usbdrvasm12.S:267    .text:00000176 overflow
usbdrv/usbdrvasm12.S:231    .text:00000142 didUnstuff7
usbdrv/usbdrvasm12.S:234    .text:00000146 unstuff7
usbdrv/usbdrvasm12.S:280    .text:0000018a doReturn
usbdrv/usbdrvasm12.S:325    .text:000001b6 handleData
usbdrv/usbdrvasm12.S:277    .text:00000184 ignorePacket
usbdrv/usbdrvasm12.S:344    .text:000001e0 handleIn
usbdrv/usbdrvasm12.S:307    .text:0000019e handleSetupOrOut
usbdrv/usbdrvasm12.S:415    .text:00000218 sendNakAndReti
usbdrv/usbdrvasm12.S:418    .text:0000021c sendAckAndReti
usbdrv/usbdrvasm12.S:421    .text:00000220 sendCntAndReti
usbdrv/usbdrvasm12.S:440    .text:00000228 usbSendAndReti
usbdrv/usbdrvasm12.S:395    .text:000001fc bitstuff0
usbdrv/usbdrvasm12.S:456    .text:00000242 didStuff0
usbdrv/usbdrvasm12.S:400    .text:00000204 bitstuff1
usbdrv/usbdrvasm12.S:462    .text:0000024c didStuff1
usbdrv/usbdrvasm12.S:403    .text:00000208 bitstuff2
usbdrv/usbdrvasm12.S:470    .text:0000025a didStuff2
usbdrv/usbdrvasm12.S:406    .text:0000020c bitstuff3
usbdrv/usbdrvasm12.S:478    .text:00000268 didStuff3
usbdrv/usbdrvasm12.S:409    .text:00000210 bitstuff4
usbdrv/usbdrvasm12.S:490    .text:0000027e didStuff4
usbdrv/usbdrvasm12.S:423    .text:00000222 usbSendX3
usbdrv/usbdrvasm12.S:450    .text:00000238 txLoop
usbdrv/usbdrvasm12.S:496    .text:00000288 didStuff5
usbdrv/usbdrvasm12.S:547    .text:000002de bitstuff5
usbdrv/usbdrvasm12.S:504    .text:00000296 didStuff6
usbdrv/usbdrvasm12.S:550    .text:000002e2 bitstuff6
usbdrv/usbdrvasm12.S:512    .text:000002a4 didStuff7
usbdrv/usbdrvasm12.S:553    .text:000002e6 bitstuff7
usbdrv/usbdrvasm12.S:533    .text:000002c8 skipAddrAssign

UNDEFINED SYMBOLS
usbInputBufOffset
usbRxBuf
usbDeviceAddr
usbCurrentTok
usbRxLen
usbRxToken
usbTxLen
usbTxBuf
usbNewDeviceAddr
